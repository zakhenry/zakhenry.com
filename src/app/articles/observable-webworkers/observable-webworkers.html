<zh-article-container date="2019-06-16">

  <h1 ngProjectAs="title">Observable Web Workers with Angular - Introduction</h1>

  <h2>
    tl;dr
  </h2>

  <p>Web Workers are awesome and Angular CLI now supports them natively.<br><br>
    Unfortunately, the Web Worker API is not Angular-like and therefore, I'm introducing a library <a
      href="https://www.npmjs.com/package/observable-webworker" target="_blank" rel="noopener noreferrer"><code>observable-webworker</code></a>
  </p>

  <p>If you already know what web workers are and how to use them in Angular, feel free to <a
    href="#implementing-observablewebworker">skip ahead</a> where I will show you how to refactor the initial worker
    generated by the CLI into a superpowered worker with <code>observable-webworker</code>.</p>
  <h2>
    Context
  </h2>

  <p>In this article series we will explore using <a
    href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank"
    rel="noopener noreferrer">Web Workers</a> to offload heavy computation to another thread. Keeping the main thread free
    for interaction with the user is important. We don't typically think of threading very often in the frontend world, as
    non-blocking APIs and the event loop model of Javascript typically allows us to have execution of user interaction
    events <em>in-between</em> longer running processes such as waiting for an HTTP request to resolve.</p>

  <p>Because of this, for the most part, you don't need threading or web workers for most tasks. However, there are a set
    of problems that do require heavy computation that would ordinarily block the main thread, and therefore user
    interaction (or modification of the DOM). This issue can manifest itself in stuttering animations, unresponsive
    inputs, buttons that appear not to work immediately etc.</p>

  <p>Often the answer to this has been to run intensive computations server side, then send the result back to the browser
    once done. This solution does have a real cost however - you need to manage a server API, monetarily computation
    itself isn't free (you're paying for the server) and there may be a significant latency issue if you need to interact
    with the computation frequently.</p>

  <p>Fortunately, <code>Web Workers</code> are the solution to all this - they allow you to schedule units of work in
    browser that run <em>in parallel</em> to the main execution context, then once done can pass their result back to the
    main thread for rendering in the DOM etc.</p>
  <h2>
    Creating your first Web Worker in Angular
  </h2>

  <p>The worker API is relatively simple - in Typescript you can create a new worker with just</p>


  <!--@todo code -->


  <p>This is all very well, however we love to use Typescript, and be able to import other files etc. Being stuck with a
    single javascript file is not very scalable.</p>

  <p>Previously working with workers (heh) in Angular was fairly painful as bundling them requires custom Webpack
    configuration. However, Angular CLI version 8 brings built-in support for properly compiling &amp; bundling web
    workers.</p>

  <p>The docs are at <a href="https://angular.io/guide/web-worker" target="_blank" rel="noopener noreferrer">https://angular.io/guide/web-worker</a>
    but we will step through everything required (and more!) here.</p>

  <p>Before we get going, we've set up an empty Angular CLI project with<br>
  </p>

  <!--@todo code -->


  <p>Next we need to enable web worker support, so we run<br>
  </p>

  <!--@todo code -->


  <p>We're prompted for a name, so we will call it demo.</p>

  <p>Angular CLI will now update <code>tsconfig.app.json</code> and <code>angular.json</code> to enable web worker
    support, and create us a new <code>demo.worker.ts</code>:</p>


  <!--@todo code -->


  <p>To get this worker running, lets update our <code>AppComponent</code>:</p>


  <!--@todo code -->


  <p>And the template:</p>

  <!--@todo code -->

  <p>Okay, so now we're all good to go, run the application if you aren't already, and you'll be greeted with a single
    button in the DOM. Are you excited yet?</p>

  <p>Click that sucker, and you will see in the dev console<br>
  </p>
  <!--@todo code -->


  <p>Yeehaw, we got a response from a separate thread, and <strong>Angular compiled the worker for us</strong>.</p>

  <p>Also, to prove this is actually a worker, if you go to the <code>Sources</code> tab in Chrome, you will see that
    there is a worker running there as <code>1.worker.js</code>.</p>

  <p>The fact that we can still see it running is important - it means that we have not destroyed the worker, despite
    receiving the only message we will get back from it. If we click the button again, we will construct a brand new
    worker, and the old one will continue to hang around. This is a bad idea! We should always clean up after we're done
    with a worker.</p>

  <p>Before we worry about how to destroy a worker, let's reflect for a bit on the API that we have with workers so far -
    we need to:</p>

  <ul>
    <li>construct the worker
    </li>
    <li>declare a property and assign a function to it in order to get the response back from the worker</li>
    <li>
      <code>addEventListener</code> within the worker itself, we have to
    </li>
    <li>call a global <code>postMessage</code> function to send back information to the main thread</li>
  </ul>

  <p>This API doesn't feel very Angular-like does it? We're used to deal with clean hook-based APIs and have fallen in
    love with RxJS for dealing with streams of data and asynchronous responses, why can't we have this for Web Workers
    too?</p>

  <p>Well, we can. And this happens to be the whole point of this article. I'd like to introduce a new library <a
    href="https://www.npmjs.com/package/observable-webworker" target="_blank" rel="noopener noreferrer"><code>observable-webworker</code></a>
    which seeks to address this clunky API and give us a familiar experience we're used to with Angular.</p>

  <p>I should note that this library doesn't actually depend on Angular at all, and will work beautifully with React or
    any other framework or lack thereof! The only dependency is a <code>peerDependency</code> on RxJS.</p>

  <p>To best introduce the concepts of the library, we will refactor our current web worker to use <code>observable-webworker</code>.
  </p>

  <h2>
    <a href="#implementing-observablewebworker" class="anchor">
    </a>
    Implementing observable-webworker
  </h2>

  <p>To start, we will install <code>observable-webworker</code>. I'm using Yarn, but you know how to install packages
    right?!<br>
  </p>

  <pre class="highlight shell"><code> yarn add -E observable-webworker</code></pre>


  <p>First of all, we'll update the <code>AppComponent</code></p>

  <!--@todo code -->


  <p>Note we've imported <code>fromWorker</code> from <code>observable-webworker</code>. The first argument is a worker
    <em>factory</em> - we need to have the ability to lazily construct a worker on-demand, so we pass a factory and the
    library can construct it when needed. Also Webpack needs to find the <code>new Worker('./path/to/file.worker')</code>
    in the code in order to be able to bundle it for us.<br>
    The second argument <code>input$</code> is a simple stream of messages that will go to the worker. The generics
    (<code>&lt;string, string&gt;</code>) that we pass to the worker indicate the input and output types. In our case the
    input is a very simple <code>of('hello')</code>.</p>

  <p>Now for the worker:</p>


  <pre><code [textContent]="worker"></code></pre>

  <p>You can see we have completely restructured the worker to use an API that is far more familiar to Angular developers
    - we use a decorator <code>@ObservableWorker ()</code> which lets the library bootstrap and work its magic, and we
    implement the <code>DoWork</code> interface, which requires us to create a <code>public work(input$: Observable&lt;string&gt;):
      Observable&lt;string&gt;;</code> method.</p>

  <p>The actual content of the method is super simple. We process the observable stream with a simple <code>map</code>,
    which is returned from the method. Behind the scenes the library will call <code>postMessage</code> to get the data
    back to the main thread.</p>

  <p>You can now run the application again and it will work exactly as before, with the one exception that the worker will
    automatically be terminated as no more work needs to be done.</p>

  <p>As we're now using observables, the library is able to know when subscribers have finished listening and can clean up
    the worker appropriately.</p>

  <p>This wraps up Part One of this series. In later articles we will discuss a more real-world implementation of workers,
    how to deal with errors, and how to work with very large object passing between main and worker threads. Possibly I
    will also do a deep dive into the implementation of observable-webworker as it uses some of the more exotic RxJS
    operators like <code>materialize()</code> and <code>dematerialize()</code>.</p>

  <p>All of these features are available with <code>observable-webworker</code> now, so I encourage you to <a
    href="https://github.com/cloudnc/observable-webworker#observablewebworker" target="_blank" rel="noopener noreferrer">check
    out the readme</a>, as it goes into more detail about the features than I do here in this article.</p>


  <hr>

  <p>This is my first blog post ever! I'd love to hear from you if you have any feedback at all, good or bad!</p>


</zh-article-container>
